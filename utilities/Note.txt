NOTA 1
Se schematizziamo all'osso la procedura della Common Mutal Authentication, notiamo che segue uno schema di questo tipo:
CLIENT HELLO --> SERVER HELLO + INVIO DI SIGNATURE E CERTIFICATO DA PARTE DEL SERVER --> INVIO DI SIGNATURE E CERTIFICATO DA PARTE DEL CLIENT
La struttura di questa mutua autenticazione è molto simile all'handshake di TLS v1.2 e molto diversa dall'handshake di TLS v1.3.
Non sembrano esservi riferimenti alla cifratura.
Osservazione: il server SM-DP+, con la sua chiave privata, genera una signature comprendente sia la propria challenge che la challenge dell'eUICC.
D'altra parte, l'eUICC, con la sua chiave privata, genera una signature comprendente solo la challenge del server.

NOTA 2
All'interno di https://arxiv.org/pdf/2211.15323.pdf sono già state studiate delle vulnerabilità del protocollo ed è emerso che:
a) Se si usa un server SM-DP+ compromesso a fianco di quello coinvolto nella comunicazione RSP e non c'è TLS tra LPA e SM-DP+, allora l'attaccante può deviare la comunicazione verso il server compromesso. Così l'eUICC accetta anche i profili fake generati dal server compromesso. La vulnerabilità potrebbe essere dovuta al fatto che non viene utilizzato l'OID nei messaggi che trasportano i profili.
b) Se l'attaccante possiede l'eUICC U, viene compromesso un altro eUICC U', non c'è TLS tra LPA e SM-DP+ e si ricorre all'approccio activation code, allora l'attaccante può rubare l'activation code dall'utente possessore di U, firmarlo con la chiave privata dell'eUICC compromesso (U') e inviare il messaggio spoofed al server. Così il server manda il nuovo profilo a U'. La vulnerabilità potrebbe essere dovuta al fatto che nel server non viene registrato l'ID dell'eUICC target quando viene ordinato un profilo.
c) L'attaccante può scaricare un profilo in modo illegittimo sul proprio eUICC in uno dei seguenti due modi: il primo modo consiste nell'impersonare un utente legittimo e portare il download sul proprio eUICC; il secondo modo consiste nel ricostruire l'activation code a partire da leak di informazioni lasciati dall'utente vittima, dall'operatore oppure da una LPA modificata. La vulnerabilità potrebbe essere dovuta al fatto che, quando un utente richiede il download di un profilo, l'operatore non verifica attentamente la sua identità.
d) L'attaccante può scaricare un profilo nell'eUICC vittima con la propria sottoscrizione (e quindi in modo illegittimo) in uno dei seguenti due modi: il primo modo consiste nel conoscere l'ID dell'eUICC vittima e richiedere il download del profilo per conto dell'eUICC vittima; il secondo modo consiste nell'iniettare un activation code, ad esempio tramite una LPA modificata.
e) Se si hanno due server SM-DP+ (S, S'), tra cui S' è compromesso, e non c'è TLS tra LPA e SM-DP+, allora l'attaccante può far impersonare S in S' e far sì che, in una mutua autenticazione tra l'eUICC e SM-DP+, S creda di aver autenticato l'eUICC e l'eUICC creda di aver autenticato S'. La vulnerabilità potrebbe essere dovuta al fatto che, apparentemente, l'OID non viene incluso nei messaggi iniziali della Common Mutual Authentication.
f) Se si hanno due eUICC (U, U'), tra cui U' è compromesso, e non c'è TLS tra LPA e SM-DP+, allora l'attaccante può intercettare l'autenticazione tra U e il server SM-DP+, in modo tale che U creda di aver autenticato il server e il server creda di aver autenticato U'. La vulnerabilità potrebbe essere dovuta al fatto che, apparentemente, l'EID non viene incluso nei messaggi iniziali della Common Mutual Authentication.
g) Se non c'è TLS tra LPA e SM-DP+ e si ricorre all'approccio activation code, allora, anche senza componenti compromessi, potrebbero rimanere dei leak di informazione riguardanti l'activation code.
Badiamo che tutti i punti eccetto (c), (d) fanno riferimento a vulnerabilità che occorrebbero nel caso in cui non si avesse TLS tra LPA e SM-DP+. D'altro canto, solo i punti (e), (f) fanno riferimento alla Common Mutual Authentication in senso stretto e non al download dei profili.

NOTA 3
TARIFFE DOWNLOAD PROFILI eSIM
Iliad: l'attivazione costa 10€ e l'offerta più scrausa è a 4,99€/mese.
Spusu: l'attivazione è gratuita e l'offerta più scrausa è a 3,99€/mese.
TIM: l'attivazione costa 10€, la sostituzione costa 15€ e l'offerta più scrausa è a 7,99€/mese.
Very Mobile: l'attivazione è gratuita e l'offerta più scrausa è a 4,99€/mese.
Vodafone: l'attivazione costa 1€, la sostituzione costa 10€ e l'offerta più scrausa è a 14,99€/mese.
WindTre: l'attivazione costa 10€, la sostituzione costa 15€ e l'offerta più scrausa è a 12,99€/mese.

NOTA 4
Il problema della signature di 70-73 byte in formato DER è stato affrontato nel seguente modo, con l'aiuto della libreria ecdsa di Python (è l'unico modo che ho trovato in un pomeriggio di ricerche):
    #genera euiccSignature1 firmando euiccSigned1 (= byte_euiccSigned1.decode()) con la chiave privata euiccPrivKey
    der_euiccSignature1 = euiccPrivKey.sign(byte_euiccSigned1, ec.ECDSA(hashes.SHA256()))
    #der_euiccSignature1 è in formato DER (con una dimensione di 70-73 byte): ci facciamo aiutare dalla libreria ecdsa.util per convertirla in row byte (64 byte).
    euiccSignature1_first_half_int, euiccSignature1_second_half_int = ecdsa.util.sigdecode_der(der_euiccSignature1, ecdsa.NIST256p.order)   #NIST256p == SECP256R1
    euiccSignature1_first_half = euiccSignature1_first_half_int.to_bytes((euiccSignature1_first_half_int.bit_length() + 7) // 8, byteorder=ENDIANESS)
    euiccSignature1_second_half = euiccSignature1_second_half_int.to_bytes((euiccSignature1_second_half_int.bit_length() + 7) // 8, byteorder=ENDIANESS)
    euiccSignature1 = bytes(euiccSignature1_first_half + euiccSignature1_second_half)
Mi sono anche accorto che il campo ASN.1 relativo alla signature deve essere definito come tag.tagClassApplication e non come tag.tagClassContext: in questo modo, il tag di questo campo è pari a 5F37 (come richiesto dalle specifiche) e non più pari a 9F37. È stata proprio quest'ultima correzione a risolvere l'errore "tlv not valid", che tuttavia è stato sostituito dall'errore "Internal error while verifying the signature". Ho provato a inizializzare il campo euiccSignature1 sia con la signature di 70-73 byte in formato DER, sia con la signature portata a 64 byte, sia ponendo euiccSignature1 = bytes(euiccSignature1_second_half + euiccSignature1_first_half), ma rimane sempre "Internal error while verifying the signature". Questo almeno per quanto riguarda HOSTNAME = "sys.prod.ondemandconnectivity.com". Per quanto concerne HOSTNAME = "lpa.ds.gsma.com", invece, si ha un JSONDecodeError per la seconda risposta del server.
AGGIORNAMENTO (25/10/2023): ho effettuato diverse prove di invio di messaggi ai due server SM-DP+ (in stille 'fuzzing'), i quali danno messaggi di errori diversi (anche tra loro) al variare del contenuto dei messaggi inviati (i.e. al variare della transactionId, della signature, dei certificati). Le varie risposte (i.e. i vari messaggi di errore) dei server sono riportati nel file Word Risposte-server.docx.

NOTA 5
PIATTAFORMA DI TEST
Dal capitolo 3 del documento SGP.23-v1.0 (tratto dalla documentazione ufficiale di GSMA) emerge che:
a) L'implementazione dei simulatori per i casi di test è sotto la responsabilità di chi fornisce i tool per il testing.
b) Per quanto riguarda l'ambiente di test per l'eUICC, quest'ultimo deve supportare Java Card™ (che è una piattaforma sw che consente di eseguire app Java su dispositivi integrati proprio come le SIM card e gli eUICC); inoltre, devono essere forniti prodotti dei form factor specificati in ETSI TS 102 221 (i.e. ID-1 UICC, Plug-in UICC, Mini-UICC, 4FF) e prodotti conformi ad Annex G.2.
c) Per quanto riguarda l'ambiente di test per il server, deve essere fornita una definizione della configurazione TLS e devono essere utilizzati dei dati in formato JSON e ASN.1.
d) Per quanto riguarda l'ambiente di test per l'LPA, il dispositivo deve contenere un eUICC (fisso o removibile) configurato con dei certificati e delle chiavi di test; l'eUICC non deve supportare LPAe e il certificato root di test deve essere configurato nel dispositivo.
e) Si parla di un companion device (contenente l'eUICC di test e l'LPAd) direttamente connesso a un primary device.
In definitiva, almeno per quanto concerne eUICC e LPA, sembra che si parli di un ambiente di testing composto rispettivamente da un eUICC reale e da una LPA installata in un apposito dispositivo (contesto reale).
D'altra parte, nel video https://www.youtube.com/watch?v=5oecn43xsDg, emerge che alcuni pc con Windows 10 supportano direttamente la eSIM (io con Windows 11 non ho questa feature).

NOTA 6
Il video menzionato nella nota 5 (https://www.youtube.com/watch?v=5oecn43xsDg) parla di possibili aspetti di sicurezza concernenti le eSIM che possono essere affrontati, come:
a) Come deployare un profilo definito direttamente da noi.
b) Come installare applicazioni custom nell'eUICC.
c) Trovare qualche vulnerabilità dell'eUICC (utilizzo di toolkit per catturare info, esecuzione di comandi su una macchina vittima mediante una connessione definita da noi, ecc.).
Comunque sia, chi ha condotto questo talk non ha trovato problemi o vulnerabilità nel protocollo in sé.